<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>BeiChen Christmas v1.5.0</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Mountains+of+Christmas:wght@400;700&display=swap" rel="stylesheet">

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #050000; /* æ›´æ·±é‚ƒçš„èƒŒæ™¯ */
      font-family: 'Cinzel', serif; /* é»˜è®¤å­—ä½“æ”¹ä¸ºè¡¬çº¿ä½“ */
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    
    #canvas-wrapper { 
      position: relative; 
      box-shadow: 0 0 80px rgba(255, 0, 0, 0.15); /* çº¢è‰²æ°›å›´å…‰ */
      background: #000; 
    }
    #canvas-container { width: 100%; height: 100%; display: block; }

    /* è§†é¢‘æ¡†ä¼˜åŒ–ï¼šåŠ é‡‘è¾¹ */
    #video-container {
      position: absolute; top: 25px; right: 25px;
      width: 160px; height: 120px; z-index: 2;
      border: 2px solid #d4af37; /* é‡‘è¾¹ */
      border-radius: 12px;
      overflow: hidden;
      transform: scaleX(-1);
      box-shadow: 0 4px 15px rgba(0,0,0,0.8);
      background: rgba(0,0,0,0.8);
      transition: opacity 0.35s;
    }
    #input-video {
      width: 100%; height: 100%; object-fit: cover; opacity: 0.8;
      position: absolute; top: 0; left: 0;
    }
    #skeleton-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; }
    .hide-video #video-container { opacity: 0; pointer-events: none; }

    /* --- UI å±‚é‡æ–°è®¾è®¡ --- */
    #ui-layer {
      position: absolute; top: 40px; left: 40px;
      z-index: 3; pointer-events: none;
      color: #fff;
      transition: opacity 0.35s;
      display: flex; flex-direction: column; align-items: flex-start; gap: 15px;
    }

    h1 {
      font-family: 'Mountains of Christmas', cursive; /* åœ£è¯å­—ä½“ */
      font-weight: 700;
      font-size: 3.2rem;
      margin: 0;
      /* ç»å…¸çº¢é‡‘æ¸å˜ */
      background: linear-gradient(to bottom, #fff 20%, #ffd700 80%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 2px 10px rgba(255, 215, 0, 0.3);
      filter: drop-shadow(0 0 2px #000);
    }

    #status-text {
      font-size: 1rem; color: #ffd700; 
      font-weight: bold; letter-spacing: 1px;
      text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
    }

    .instructions {
      pointer-events: auto;
      font-size: 0.95rem; color: #f0f0f0;
      line-height: 1.8;
      width: 280px;
      /* åœ£è¯å¡ç‰‡é£æ ¼èƒŒæ™¯ */
      background: linear-gradient(135deg, rgba(60, 10, 10, 0.85), rgba(30, 5, 5, 0.95));
      padding: 20px 25px;
      border-radius: 16px;
      border: 1px solid rgba(255, 215, 0, 0.3);
      box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 0 20px rgba(100,0,0,0.2);
      position: relative;
    }
    /* é¡¶éƒ¨é‡‘è‰²è£…é¥°æ¡ */
    .instructions::before {
      content: ''; position: absolute; top: 6px; left: 6px; right: 6px; bottom: 6px;
      border: 1px dashed rgba(255, 215, 0, 0.3); border-radius: 10px; pointer-events: none;
    }

    .highlight { color: #ff4d4d; font-weight: bold; text-shadow: 0 0 2px rgba(255,0,0,0.5); }
    
    /* æŒ‰é’®ä¼˜åŒ–ï¼šé‡‘è‰²æŒ‰é’® */
    #upload-btn {
      pointer-events: auto;
      background: linear-gradient(to bottom, #d4af37, #b48f17);
      border: 1px solid #ffd700;
      color: #1a0500;
      padding: 12px 32px;
      cursor: pointer;
      text-transform: uppercase;
      font-family: 'Cinzel', serif;
      font-weight: bold;
      font-size: 0.9rem;
      margin-top: 10px;
      transition: all 0.3s ease;
      letter-spacing: 2px;
      border-radius: 50px; /* èƒ¶å›Šå½¢ */
      box-shadow: 0 4px 15px rgba(212, 175, 55, 0.3);
    }
    #upload-btn:hover { 
      background: linear-gradient(to bottom, #ebd578, #d4af37);
      box-shadow: 0 0 25px rgba(212, 175, 55, 0.6);
      transform: translateY(-2px);
    }
    #file-input { display: none; }

    #loading {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'Mountains of Christmas', cursive;
      color: #d4af37;
      font-size: 2rem;
      z-index: 10;
      pointer-events: none;
      transition: opacity 0.35s;
      text-shadow: 0 0 10px rgba(212,175,55,0.5);
    }

    /* å³ä¸Šè§’æ§åˆ¶æŒ‰é’® */
    .control-btn {
      position: absolute; top: 30px; z-index: 20;
      background: rgba(0,0,0,0.4);
      color: #d4af37;
      border: 1px solid rgba(212, 175, 55, 0.5);
      width: 44px; height: 44px;
      border-radius: 50%;
      cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      font-size: 1.2rem;
      transition: all 0.25s;
      backdrop-filter: blur(4px);
    }
    .control-btn:hover { 
      background: rgba(212, 175, 55, 0.2); 
      color: #fff; 
      border-color: #fff; 
      box-shadow: 0 0 15px rgba(212, 175, 55, 0.4);
    }
    #fullscreen-btn { right: 200px; }
    #camera-btn { right: 145px; }

    .hide-ui #ui-layer, .hide-ui #upload-btn { opacity: 0; pointer-events: none; }
    .hide-ui #loading { opacity: 0; pointer-events: none; }
    .hide-ui .control-btn { opacity: 0.3; }
    .hide-ui .control-btn:hover { opacity: 1; }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
        "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/+esm"
      }
    }
  </script>
</head>

<body>
  <div id="canvas-wrapper">
    <div id="canvas-container"></div>

    <div id="video-container">
      <video id="input-video" autoplay playsinline muted></video>
      <canvas id="skeleton-canvas"></canvas>
    </div>

    <button id="camera-btn" class="control-btn" title="æ˜¾ç¤º/éšè—æ‘„åƒå¤´é¢„è§ˆ">ğŸ“·</button>
    <button id="fullscreen-btn" class="control-btn" title="åˆ‡æ¢æ²‰æµ¸æ¨¡å¼">â›¶</button>

    <div id="ui-layer">
      <h1>BeiChen Christmas</h1>
      <div id="status-text">Creating Magic...</div>
      <div class="instructions">
        <div style="margin-bottom:8px; border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:5px; color:#aaa; font-size:0.8rem;">æ§åˆ¶è¯´æ˜</div>
        â€¢ <span class="highlight">æ¡æ‹³</span> : åœ£è¯æ ‘<br/>
        â€¢ <span class="highlight">å¼ æ‰‹</span> : ç²’å­æ•£å¼€<br/>
        â€¢ <span class="highlight">å³æŒ¥åŠ¨</span> : æƒ¯æ€§è½¬åŠ¨<br/>
        â€¢ <span class="highlight">æåˆ</span> : é€‰å–å›¾ç‰‡
      </div>
      <button id="upload-btn" onclick="document.getElementById('file-input').click()">ä¸Šä¼ å›¾ç‰‡</button>
      <input type="file" id="file-input" multiple accept="image/*">
    </div>

    <div id="loading">Loading Magic...</div>
  </div>

<script type="module">
  import * as THREE from 'three';
  import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
  import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
  import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

  // ======================
  // é…ç½®
  // ======================
  const CONFIG = {
    goldCount: 600, silverCount: 600, gemCount: 400, emeraldCount: 400,
    dustCount: 1600,
    treeHeight: 75, maxRadius: 30,
    snowFarMax: 1400, snowNearMax: 900,
    snowFarInit: 1200, snowNearInit: 800,
    xmasReplaceRatio: 0.30, ribbonReplaceRatio: 0.20,
    pineCount: 2600,
    lightsCount: 240, // å‘¼å¸ç¯æ•°é‡
    fpsLow: 42, fpsHigh: 55
  };

  const STATE = { TREE: 'tree', SCATTER: 'scatter', ZOOM: 'zoom' };
  let currentState = STATE.TREE;

  let scene, camera, renderer, composer, bloomPass;
  const mainGroup = new THREE.Group();
  const dummy = new THREE.Object3D();
  let time = 0;

  let windTime = 0;
  let wind = { x: 0, z: 0, strength: 0 };

  let handPos = { x: 0, y: 0 };
  let lastHandPos = { x: 0, y: 0 };
  let isHandPresent = false;
  let rotationVelocity = { x: 0, y: 0 };

  const photoMeshes = [];
  let zoomTargetIndex = -1;

  let goldMesh, silverMesh, gemMesh, emeraldMesh;
  let caneMesh, candyMesh, bellMesh, bowMesh;
  let dustSystem;
  let ribbonCaneMesh, ribbonCandyMesh, ribbonBellMesh, ribbonBowMesh;
  const ribbonCaneData = [], ribbonCandyData = [], ribbonBellData = [], ribbonBowData = [];

  let pineSystem;
  let pineBase = []; 
  let currentBasePineOpacity = 0.42; 

  let lightMesh;
  let lightData = [];

  let snowFarSystem, snowNearSystem;
  let snowFarData = [], snowNearData = [];

  const logicData = {
    gold: [], silver: [], gem: [], emerald: [],
    cane: [], candy: [], bell: [], bow: [],
    dust: [], star: null
  };

  const QUALITY = { HIGH: 0, MED: 1, LOW: 2 };
  let qualityLevel = QUALITY.HIGH;

  // æ‰‹æœºç«¯é»˜è®¤ç¨é™ç”»è´¨ï¼Œé¿å…ä¸€ä¸Šæ¥å°±æ‰å¸§
  const IS_MOBILE = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
  if (IS_MOBILE) qualityLevel = QUALITY.MED;
  let fpsAvg = 60, fpsAccum = 0, fpsCount = 0, lastFrameT = performance.now();

  const wrapperEl = document.getElementById('canvas-wrapper');
  const fullscreenBtn = document.getElementById('fullscreen-btn');
  const cameraBtn = document.getElementById('camera-btn');

  fullscreenBtn.onclick = () => wrapperEl.classList.toggle('hide-ui');
  cameraBtn.onclick = () => {
    wrapperEl.classList.toggle('hide-video');
    cameraBtn.textContent = wrapperEl.classList.contains('hide-video') ? 'ğŸš«' : 'ğŸ“·';
  };

  function updateDimensions() {
    const targetAspect = 4 / 3;
    const windowAspect = window.innerWidth / window.innerHeight;
    let width, height;
    if (windowAspect > targetAspect) {
      height = window.innerHeight; width = height * targetAspect;
    } else {
      width = window.innerWidth; height = width / targetAspect;
    }
    wrapperEl.style.width = width + 'px';
    wrapperEl.style.height = height + 'px';
    return { width, height };
  }

  function initThree() {
    const container = document.getElementById('canvas-container');
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020000); // ææš—çº¢é»‘èƒŒæ™¯
    scene.fog = new THREE.FogExp2(0x020000, 0.0026);

    const dims = updateDimensions();
    camera = new THREE.PerspectiveCamera(50, dims.width / dims.height, 0.1, 1500);
    camera.position.set(0, 0, 110);

    renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(dims.width, dims.height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    container.appendChild(renderer.domElement);

    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

    scene.add(new THREE.AmbientLight(0xffffff, 0.3));
    const spotLight = new THREE.SpotLight(0xffddaa, 80);
    spotLight.position.set(30, 60, 50); spotLight.angle = Math.PI / 4; spotLight.penumbra = 1;
    scene.add(spotLight);
    const blueLight = new THREE.PointLight(0xaaddff, 40, 100);
    blueLight.position.set(-30, -20, 30);
    scene.add(blueLight);

    const renderScene = new RenderPass(scene, camera);
    bloomPass = new UnrealBloomPass(new THREE.Vector2(dims.width, dims.height), 1.5, 0.4, 0.85);
    bloomPass.threshold = 0.35; // ç¨å¾®é™ä½é˜ˆå€¼è®©ç¯æ›´å®¹æ˜“å‘å…‰
    bloomPass.strength = 0.75;  // å¢å¼ºè¾‰å…‰å¼ºåº¦
    bloomPass.radius = 0.55;

    composer = new EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    createTreeOrnamentsWithReplacements();
    createPineSilhouette();
    createDustRibbon();
    createRibbonDecorUpgraded();
    createLightString();
    createStarField();
    createSnowLayers();

    scene.add(mainGroup);
    window.addEventListener('resize', onWindowResize);
  }

  function onWindowResize() {
    const dims = updateDimensions();
    camera.aspect = dims.width / dims.height;
    camera.updateProjectionMatrix();
    renderer.setSize(dims.width, dims.height);
    composer.setSize(dims.width, dims.height);
    bloomPass.resolution.set(dims.width, dims.height);
  }

  // ... (çº¹ç†ç”Ÿæˆã€åŸºç¡€å‡ ä½•ä½“ä»£ç ä¿æŒä¸å˜ï¼Œçœç•¥ä»¥èŠ‚çœç¯‡å¹…ï¼Œé€»è¾‘ä¸ä¸Šä¸ªç‰ˆæœ¬ä¸€è‡´) ...
  function createCaneStripeTexture() {
    const w = 256, h = 64; const canvas = document.createElement('canvas'); canvas.width = w; canvas.height = h; const ctx = canvas.getContext('2d'); ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, w, h); const stripeW = 24; ctx.fillStyle = '#ffd000'; for (let x = -w; x < w * 2; x += stripeW * 2) { ctx.save(); ctx.translate(x, 0); ctx.rotate(-Math.PI / 5.2); ctx.fillRect(0, 0, stripeW, h * 3); ctx.restore(); } const grad = ctx.createLinearGradient(0, 0, 0, h); grad.addColorStop(0.0, 'rgba(255,255,255,0.35)'); grad.addColorStop(0.5, 'rgba(255,255,255,0.00)'); grad.addColorStop(1.0, 'rgba(0,0,0,0.10)'); ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h); const tex = new THREE.CanvasTexture(canvas); tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping; tex.repeat.set(6, 1); tex.colorSpace = THREE.SRGBColorSpace; tex.needsUpdate = true; return tex;
  }
  function createTreeOrnamentsWithReplacements() {
    // ... (åŒä¸Šä¸ªç‰ˆæœ¬ï¼Œæ— æ”¹åŠ¨) ...
    const totalOriginal = CONFIG.goldCount + CONFIG.silverCount + CONFIG.gemCount + CONFIG.emeraldCount;
    const xmasCount = Math.floor(totalOriginal * CONFIG.xmasReplaceRatio);
    const normalCount = totalOriginal - xmasCount;
    let goldN = Math.floor(CONFIG.goldCount * (1 - CONFIG.xmasReplaceRatio));
    let silverN = Math.floor(CONFIG.silverCount * (1 - CONFIG.xmasReplaceRatio));
    let gemN = Math.floor(CONFIG.gemCount * (1 - CONFIG.xmasReplaceRatio));
    let emeraldN = Math.floor(CONFIG.emeraldCount * (1 - CONFIG.xmasReplaceRatio));
    const fixNormal = normalCount - (goldN + silverN + gemN + emeraldN); if (fixNormal !== 0) goldN += fixNormal;
    let caneN = Math.floor(xmasCount / 4); let candyN = Math.floor(xmasCount / 4); let bellN = Math.floor(xmasCount / 4); let bowN = xmasCount - (caneN + candyN + bellN);
    const goldMat = new THREE.MeshPhysicalMaterial({ color: 0xffaa00, metalness: 1.0, roughness: 0.15, clearcoat: 1.0, emissive: 0xaa5500, emissiveIntensity: 0.10 });
    const silverMat = new THREE.MeshPhysicalMaterial({ color: 0xeeeeee, metalness: 0.9, roughness: 0.22, clearcoat: 1.0, emissive: 0x222222, emissiveIntensity: 0.08 });
    const gemMat = new THREE.MeshPhysicalMaterial({ color: 0xff0044, metalness: 0.1, roughness: 0.03, transmission: 0.55, thickness: 1.0, emissive: 0x440011, emissiveIntensity: 0.30 });
    const emeraldMat = new THREE.MeshPhysicalMaterial({ color: 0x00aa55, metalness: 0.2, roughness: 0.10, transmission: 0.45, thickness: 1.5, emissive: 0x002211, emissiveIntensity: 0.20 });
    const caneTex = createCaneStripeTexture();
    const caneMat = new THREE.MeshPhysicalMaterial({ color: 0xffffff, map: caneTex, metalness: 0.10, roughness: 0.28, clearcoat: 1.0, clearcoatRoughness: 0.2, emissive: 0x111111, emissiveIntensity: 0.05 });
    const candyMat = new THREE.MeshPhysicalMaterial({ color: 0xff3355, metalness: 0.15, roughness: 0.22, clearcoat: 1.0, clearcoatRoughness: 0.15, emissive: 0x220011, emissiveIntensity: 0.16 });
    const bellMat = new THREE.MeshPhysicalMaterial({ color: 0xffd700, metalness: 1.0, roughness: 0.16, clearcoat: 1.0, emissive: 0xaa7700, emissiveIntensity: 0.28 });
    const bowMat = new THREE.MeshPhysicalMaterial({ color: 0xff0044, metalness: 0.05, roughness: 0.55, clearcoat: 0.6, clearcoatRoughness: 0.35, emissive: 0x330011, emissiveIntensity: 0.18 });
    const sphereGeo = new THREE.SphereGeometry(0.7, 16, 16); const boxGeo = new THREE.BoxGeometry(0.9, 0.9, 0.9); const diamondGeo = new THREE.OctahedronGeometry(0.8, 0); const coneGeo = new THREE.ConeGeometry(0.5, 1.2, 8);
    const caneGeo = new THREE.TubeGeometry(makeCandyCaneCurve(), 48, 0.18, 10, false); const candyGeo = new THREE.CapsuleGeometry(0.35, 0.6, 6, 10);
    const bellGeo = makeBellGeometry(); const bowGeo = new THREE.TorusKnotGeometry(0.35, 0.12, 80, 10, 2, 3);
    goldMesh = createInstancedMesh(sphereGeo, goldMat, goldN, logicData.gold); silverMesh = createInstancedMesh(boxGeo, silverMat, silverN, logicData.silver); gemMesh = createInstancedMesh(diamondGeo, gemMat, gemN, logicData.gem); emeraldMesh = createInstancedMesh(coneGeo, emeraldMat, emeraldN, logicData.emerald);
    caneMesh = createInstancedMesh(caneGeo, caneMat, caneN, logicData.cane); candyMesh = createInstancedMesh(candyGeo, candyMat, candyN, logicData.candy); bellMesh = createInstancedMesh(bellGeo, bellMat, bellN, logicData.bell); bowMesh = createInstancedMesh(bowGeo, bowMat, bowN, logicData.bow);
    const totalNow = goldN + silverN + gemN + emeraldN + caneN + candyN + bellN + bowN; const slots = []; for (let i = 0; i < totalNow; i++) slots.push(generateEvenTreeSlot(i, totalNow)); shuffleArray(slots);
    let cursor = 0;
    cursor = fillSlotsToData(slots, cursor, logicData.gold, { baseScale: [0.6, 1.4], rot: 0.03 }); cursor = fillSlotsToData(slots, cursor, logicData.silver, { baseScale: [0.6, 1.4], rot: 0.03 }); cursor = fillSlotsToData(slots, cursor, logicData.gem, { baseScale: [0.6, 1.4], rot: 0.03 }); cursor = fillSlotsToData(slots, cursor, logicData.emerald, { baseScale: [0.6, 1.4], rot: 0.03 });
    cursor = fillSlotsToData(slots, cursor, logicData.cane, { baseScale: [0.9, 1.6], rot: 0.02 }); cursor = fillSlotsToData(slots, cursor, logicData.candy, { baseScale: [0.9, 1.6], rot: 0.02 }); cursor = fillSlotsToData(slots, cursor, logicData.bell, { baseScale: [0.9, 1.6], rot: 0.02 }); cursor = fillSlotsToData(slots, cursor, logicData.bow, { baseScale: [0.9, 1.6], rot: 0.02 });
    const star = createTopStarMesh(); mainGroup.add(star); logicData.star = star;
  }
  function createInstancedMesh(geo, mat, count, dataArray) {
    const mesh = new THREE.InstancedMesh(geo, mat, count); mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage); mainGroup.add(mesh);
    dataArray.length = 0; for (let i = 0; i < count; i++) { dataArray.push({ treePos: new THREE.Vector3(), scatterPos: new THREE.Vector3(), currentPos: new THREE.Vector3(), scale: 1, rotSpeed: new THREE.Euler(), rotation: new THREE.Euler() }); } return mesh;
  }
  function generateEvenTreeSlot(i, total) {
    const t = (i + 0.5) / total; const h = (t - 0.5) * CONFIG.treeHeight + (Math.random() - 0.5) * (CONFIG.treeHeight / total) * 12; const normH = (h + CONFIG.treeHeight / 2) / CONFIG.treeHeight; const rMax = CONFIG.maxRadius * (1 - normH); const r = Math.sqrt(Math.random()) * rMax; const theta = Math.random() * Math.PI * 2; return { treePos: new THREE.Vector3(r * Math.cos(theta), h, r * Math.sin(theta)), scatterPos: randomSpherePoint(40 + Math.random() * 40) };
  }
  function fillSlotsToData(slots, startIndex, dataArray, opt) {
    for (let k = 0; k < dataArray.length; k++) { const slot = slots[startIndex + k]; dataArray[k].treePos = slot.treePos; dataArray[k].scatterPos = slot.scatterPos; dataArray[k].currentPos = slot.treePos.clone(); dataArray[k].scale = opt.baseScale[0] + Math.random() * (opt.baseScale[1] - opt.baseScale[0]); dataArray[k].rotSpeed = new THREE.Euler(Math.random() * opt.rot, Math.random() * opt.rot, Math.random() * opt.rot); dataArray[k].rotation = new THREE.Euler(Math.random() * Math.PI, Math.random() * Math.PI, 0); } return startIndex + dataArray.length;
  }
  function createTopStarMesh() {
    const starShape = new THREE.Shape(); const points = 5; const outerRadius = 3.5; const innerRadius = 1.8; for (let i = 0; i < points * 2; i++) { const angle = (i * Math.PI) / points - Math.PI / 2; const r = (i % 2 === 0) ? outerRadius : innerRadius; const x = Math.cos(angle) * r; const y = Math.sin(angle) * r; if (i === 0) starShape.moveTo(x, y); else starShape.lineTo(x, y); } starShape.closePath(); const starGeo = new THREE.ExtrudeGeometry(starShape, { depth: 0.8, bevelEnabled: true, bevelThickness: 0.2, bevelSize: 0.2, bevelSegments: 2 }); starGeo.center(); const starMat = new THREE.MeshPhysicalMaterial({ color: 0xffd700, metalness: 1.0, roughness: 0.1, clearcoat: 1.0, emissive: 0xaa7700, emissiveIntensity: 0.85 }); const star = new THREE.Mesh(starGeo, starMat); star.userData = { treePos: new THREE.Vector3(0, CONFIG.treeHeight/2 + 3, 0), scatterPos: new THREE.Vector3(0, 60, 0) }; star.position.copy(star.userData.treePos); return star;
  }
  function makeCandyCaneCurve() { const pts = [new THREE.Vector3(0, -1.6, 0), new THREE.Vector3(0, 1.2, 0)]; const hookCenter = new THREE.Vector3(0.55, 1.2, 0); const hookR = 0.55; for (let i = 0; i <= 8; i++) { const a = Math.PI * 0.05 + (Math.PI * 0.9) * (i / 8); pts.push(new THREE.Vector3(hookCenter.x + Math.cos(a) * hookR, hookCenter.y + Math.sin(a) * hookR, 0)); } return new THREE.CatmullRomCurve3(pts); }
  function makeBellGeometry() { const profile = [new THREE.Vector2(0.00,  0.80), new THREE.Vector2(0.20,  0.78), new THREE.Vector2(0.45,  0.60), new THREE.Vector2(0.55,  0.20), new THREE.Vector2(0.60, -0.15), new THREE.Vector2(0.48, -0.55), new THREE.Vector2(0.10, -0.75), new THREE.Vector2(0.00, -0.75)]; const lathe = new THREE.LatheGeometry(profile, 24); lathe.rotateX(Math.PI); lathe.scale(0.9, 0.9, 0.9); return lathe; }
  function createPineSpriteTexture() { const size = 128; const canvas = document.createElement('canvas'); canvas.width = canvas.height = size; const ctx = canvas.getContext('2d'); const g = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2); g.addColorStop(0.0, 'rgba(140,255,170,0.85)'); g.addColorStop(0.35,'rgba(80,220,120,0.55)'); g.addColorStop(0.65,'rgba(30,120,60,0.18)'); g.addColorStop(1.0, 'rgba(0,0,0,0.0)'); ctx.fillStyle = g; ctx.beginPath(); ctx.arc(size/2, size/2, size/2, 0, Math.PI*2); ctx.fill(); const tex = new THREE.CanvasTexture(canvas); tex.colorSpace = THREE.SRGBColorSpace; tex.needsUpdate = true; return tex; }
  function createPineSilhouette() { const geo = new THREE.BufferGeometry(); const positions = new Float32Array(CONFIG.pineCount * 3); const sizes = new Float32Array(CONFIG.pineCount); const phases = new Float32Array(CONFIG.pineCount); pineBase.length = 0; for (let i = 0; i < CONFIG.pineCount; i++) { const t = Math.random(); const y = (t - 0.5) * CONFIG.treeHeight; const normH = (y + CONFIG.treeHeight/2) / CONFIG.treeHeight; const rSurface = CONFIG.maxRadius * (1 - normH); const r = rSurface * (0.78 + 0.28 * Math.random()); const theta = Math.random() * Math.PI * 2; const x = r * Math.cos(theta); const z = r * Math.sin(theta); positions[i*3] = x; positions[i*3+1] = y + (Math.random()-0.5) * 0.8; positions[i*3+2] = z; sizes[i] = 10 + Math.random() * 18; phases[i] = Math.random() * Math.PI * 2; pineBase.push({ x, y: positions[i*3+1], z, theta, t }); } geo.setAttribute('position', new THREE.BufferAttribute(positions, 3)); geo.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1)); geo.setAttribute('aPhase', new THREE.BufferAttribute(phases, 1)); const tex = createPineSpriteTexture(); const mat = new THREE.ShaderMaterial({ transparent: true, depthWrite: false, blending: THREE.AdditiveBlending, uniforms: { uMap: { value: tex }, uTime: { value: 0 }, uOpacity: { value: 0.42 } }, vertexShader: `uniform float uTime; attribute float aSize; attribute float aPhase; varying float vAlpha; void main() { vec4 mv = modelViewMatrix * vec4(position, 1.0); float dist = -mv.z; float perspective = clamp(140.0 / dist, 0.6, 3.0); vAlpha = 0.65 + 0.35 * sin(uTime * 0.8 + aPhase); gl_PointSize = aSize * perspective; gl_Position = projectionMatrix * mv; }`, fragmentShader: `uniform sampler2D uMap; uniform float uOpacity; varying float vAlpha; void main() { vec4 tex = texture2D(uMap, gl_PointCoord); vec4 col = vec4(tex.rgb, tex.a * uOpacity * vAlpha); if (col.a < 0.02) discard; gl_FragColor = col; }` }); pineSystem = new THREE.Points(geo, mat); mainGroup.add(pineSystem); }
  function updatePineSilhouette() { if (!pineSystem) return; pineSystem.material.uniforms.uTime.value = time; const targetOpacity = (currentState === STATE.TREE) ? currentBasePineOpacity : 0.0; const currentOp = pineSystem.material.uniforms.uOpacity.value; pineSystem.material.uniforms.uOpacity.value = THREE.MathUtils.lerp(currentOp, targetOpacity, 0.05); const posAttr = pineSystem.geometry.attributes.position; const pos = posAttr.array; const wx = wind.x * 0.55; const wz = wind.z * 0.55; for (let i = 0; i < pineBase.length; i++) { const b = pineBase[i]; const sway = 0.35 * (0.3 + b.t); pos[i*3] = b.x + wx * sway + Math.sin(time * 0.7 + b.theta) * 0.03; pos[i*3+1] = b.y + Math.cos(time * 0.6 + b.theta) * 0.02; pos[i*3+2] = b.z + wz * sway + Math.sin(time * 0.5 + b.theta) * 0.03; } posAttr.needsUpdate = true; }
  function createDustRibbon() { const geo = new THREE.BufferGeometry(); const pos = []; logicData.dust.length = 0; for (let i = 0; i < CONFIG.dustCount; i++) { const scatterPos = randomSpherePoint(60 + Math.random() * 20); pos.push(scatterPos.x, scatterPos.y, scatterPos.z); logicData.dust.push({ spiralT: i / CONFIG.dustCount, scatterPos, currentPos: scatterPos.clone() }); } geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3)); const dustMat = new THREE.PointsMaterial({ color: 0xff0000, size: 0.8, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, depthWrite: false }); dustSystem = new THREE.Points(geo, dustMat); mainGroup.add(dustSystem); }
  function createRibbonDecorUpgraded() { const decorTotal = Math.floor(CONFIG.dustCount * CONFIG.ribbonReplaceRatio); if (decorTotal <= 0) return; const step = Math.max(1, Math.floor(CONFIG.dustCount / decorTotal)); const picked = []; for (let idx = 0; idx < CONFIG.dustCount && picked.length < decorTotal; idx += step) picked.push(idx); ribbonCaneData.length = 0; ribbonCandyData.length = 0; ribbonBellData.length = 0; ribbonBowData.length = 0; for (let i = 0; i < picked.length; i++) { const base = { dustIndex: picked[i], rotation: new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI), rotSpeed: new THREE.Euler((Math.random()-0.5)*0.03, (Math.random()-0.5)*0.03, (Math.random()-0.5)*0.03), scale: 0.55 + Math.random() * 0.55, phase: Math.random() * Math.PI * 2 }; const mod = i % 4; if (mod === 0) ribbonCaneData.push(base); if (mod === 1) ribbonCandyData.push(base); if (mod === 2) ribbonBellData.push(base); if (mod === 3) ribbonBowData.push(base); } const caneTex = createCaneStripeTexture(); const caneMat = new THREE.MeshPhysicalMaterial({ color: 0xffffff, map: caneTex, metalness: 0.10, roughness: 0.28, clearcoat: 1.0, clearcoatRoughness: 0.2, emissive: 0x111111, emissiveIntensity: 0.05 }); const caneGeo = new THREE.TubeGeometry(makeCandyCaneCurve(), 36, 0.14, 10, false); const candyMat = new THREE.MeshPhysicalMaterial({ color: 0xff3355, metalness: 0.15, roughness: 0.22, clearcoat: 1.0, clearcoatRoughness: 0.15, emissive: 0x220011, emissiveIntensity: 0.15 }); const candyGeo = new THREE.CapsuleGeometry(0.28, 0.45, 6, 10); const bellMat = new THREE.MeshPhysicalMaterial({ color: 0xffd700, metalness: 1.0, roughness: 0.16, clearcoat: 1.0, emissive: 0xaa7700, emissiveIntensity: 0.25 }); const bellGeo = makeBellGeometry(); bellGeo.scale(0.75, 0.75, 0.75); const bowMat = new THREE.MeshPhysicalMaterial({ color: 0xff0044, metalness: 0.05, roughness: 0.55, clearcoat: 0.6, clearcoatRoughness: 0.35, emissive: 0x330011, emissiveIntensity: 0.18 }); const bowGeo = new THREE.TorusKnotGeometry(0.28, 0.10, 70, 10, 2, 3); ribbonCaneMesh = new THREE.InstancedMesh(caneGeo, caneMat, ribbonCaneData.length); ribbonCandyMesh = new THREE.InstancedMesh(candyGeo, candyMat, ribbonCandyData.length); ribbonBellMesh = new THREE.InstancedMesh(bellGeo, bellMat, ribbonBellData.length); ribbonBowMesh = new THREE.InstancedMesh(bowGeo, bowMat, ribbonBowData.length); ribbonCaneMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage); ribbonCandyMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage); ribbonBellMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage); ribbonBowMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage); mainGroup.add(ribbonCaneMesh, ribbonCandyMesh, ribbonBellMesh, ribbonBowMesh); }
  function updateDustRibbon() { const positions = dustSystem.geometry.attributes.position.array; for (let i = 0; i < logicData.dust.length; i++) { const item = logicData.dust[i]; if (currentState !== STATE.TREE) { item.currentPos.lerp(item.scatterPos, 0.05); } else { const t = item.spiralT; const h = (t - 0.5) * CONFIG.treeHeight; const normH = t; const windTwist = wind.x * 0.25 + wind.z * 0.18; const r = (CONFIG.maxRadius * (1 - normH)) + 4; const theta = t * Math.PI * 2 * 6 + windTwist * (0.6 + 1.2 * t); const targetSpiralPos = new THREE.Vector3(r * Math.cos(theta), h, r * Math.sin(theta)); item.currentPos.lerp(targetSpiralPos, 0.05); } positions[i*3] = item.currentPos.x; positions[i*3 + 1] = item.currentPos.y; positions[i*3 + 2] = item.currentPos.z; } dustSystem.geometry.attributes.position.needsUpdate = true; updateRibbonDecorMesh(ribbonCaneMesh, ribbonCaneData); updateRibbonDecorMesh(ribbonCandyMesh, ribbonCandyData); updateRibbonDecorMesh(ribbonBellMesh, ribbonBellData); updateRibbonDecorMesh(ribbonBowMesh, ribbonBowData); }
  function updateRibbonDecorMesh(mesh, dataArr) { if (!mesh || dataArr.length === 0) return; for (let i = 0; i < dataArr.length; i++) { const d = dataArr[i]; const p = logicData.dust[d.dustIndex].currentPos; d.rotation.x += d.rotSpeed.x; d.rotation.y += d.rotSpeed.y; d.rotation.z += d.rotSpeed.z; const sway = (0.18 + 0.12 * Math.sin(time + d.phase)) * wind.strength; const sx = sway * (0.6 + 0.4 * Math.sin(d.phase)); const sz = sway * (0.6 + 0.4 * Math.cos(d.phase)); const ry = Math.sin(time * 0.8 + d.phase) * 0.06 * wind.strength; dummy.position.set(p.x + wind.x * 0.25, p.y, p.z + wind.z * 0.25); dummy.rotation.set(d.rotation.x + sx, d.rotation.y + ry, d.rotation.z + sz); dummy.scale.setScalar(d.scale); dummy.updateMatrix(); mesh.setMatrixAt(i, dummy.matrix); } mesh.instanceMatrix.needsUpdate = true; }

  // =========================================================
  // âœ… æ ¸å¿ƒä¿®å¤ï¼šæ›´äº®ã€æ›´å¤§çš„ç¯ä¸²
  // =========================================================
  function createLightString() {
    // 1. å¢å¤§å°ºå¯¸ï¼š0.35 -> 0.6
    const geo = new THREE.SphereGeometry(0.6, 10, 10);
    
    // 2. ç§»é™¤ vertexColorsï¼Œçº¯ Basic æè´¨ï¼ˆé  emissiveColor æˆ–è€…ç›´æ¥é¢œè‰²é©±åŠ¨ï¼‰
    const mat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 1.0 });

    lightMesh = new THREE.InstancedMesh(geo, mat, CONFIG.lightsCount);
    lightMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    
    // 3. åˆå§‹åŒ–é¢œè‰²ç¼“å†²åŒº
    lightMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(CONFIG.lightsCount * 3), 3);

    // 4. æš–è‰²è°ƒè‰²ç›˜ (Warm & Cozy)
    const palette = [
      new THREE.Color(0xffaa00), // æ·±æ©™é‡‘
      new THREE.Color(0xffd700), // çº¯é‡‘
      new THREE.Color(0xff8800), // ç¥ç€è‰²
      new THREE.Color(0xff3300)  // æš–çº¢
    ];

    lightData.length = 0;
    for (let i = 0; i < CONFIG.lightsCount; i++) {
      const t = (i + 0.5) / CONFIG.lightsCount; 
      const y = (t - 0.5) * CONFIG.treeHeight;
      const normH = (y + CONFIG.treeHeight/2) / CONFIG.treeHeight;
      const r = (CONFIG.maxRadius * (1 - normH)) + 2.5;
      const theta = t * Math.PI * 2 * 5.2;

      lightMesh.setColorAt(i, palette[i % palette.length]);

      lightData.push({ t, baseY: y, baseTheta: theta, phase: Math.random() * Math.PI * 2, speed: 0.7 + Math.random() * 0.8, size: 0.9 + Math.random() * 0.6 });
      
      dummy.position.set(r * Math.cos(theta), y, r * Math.sin(theta)); 
      dummy.scale.setScalar(1.0); 
      dummy.updateMatrix();
      lightMesh.setMatrixAt(i, dummy.matrix);
    }
    mainGroup.add(lightMesh);
  }

  function updateLightString() {
    if (!lightMesh) return;
    
    // æš–è‰²ç›˜
    const palette = [
      new THREE.Color(0xffaa00),
      new THREE.Color(0xffd700),
      new THREE.Color(0xff8800),
      new THREE.Color(0xff3300)
    ];

    for (let i = 0; i < lightData.length; i++) {
      const d = lightData[i];
      const y = d.baseY; const normH = (y + CONFIG.treeHeight/2) / CONFIG.treeHeight;
      const r = (CONFIG.maxRadius * (1 - normH)) + 2.5;
      
      const breathe = 0.55 + 0.45 * Math.sin(time * d.speed + d.phase);
      const pulse = 0.75 + 0.25 * Math.sin(time * (d.speed * 1.7) + d.phase * 1.3);
      const glow = breathe * pulse; // 0.0 ~ 1.0
      
      const windSwing = (wind.x * 0.18 + wind.z * 0.12) * (0.4 + 0.9 * d.t);
      const theta = d.baseTheta + windSwing + Math.sin(time * 0.6 + d.phase) * 0.03;
      
      let targetPos;
      if (currentState !== STATE.TREE) { const scatter = randomSpherePoint(45); targetPos = scatter; }
      else { targetPos = new THREE.Vector3(r * Math.cos(theta), y, r * Math.sin(theta)); }
      
      const p = targetPos;
      dummy.position.set(p.x + wind.x * 0.35, p.y, p.z + wind.z * 0.35);
      dummy.scale.setScalar((0.9 + 0.6 * glow) * d.size * 0.85);
      dummy.updateMatrix();
      lightMesh.setMatrixAt(i, dummy.matrix);

      // âœ… å…³é”®ï¼š HDR é¢œè‰²ä¹˜æ³• (è®©æ•°å€¼è¶…è¿‡ 1.0 ä»¥è§¦å‘ Bloom)
      const baseCol = palette[i % palette.length].clone();
      
      // å˜äº®é€»è¾‘ï¼šåŸºç¡€è‰² * (é«˜å¼ºåº¦ç³»æ•°)
      // é—ªçƒæ—¶ï¼Œäº®åº¦åœ¨ 1.5 åˆ° 5.0 ä¹‹é—´æ³¢åŠ¨ -> å¼ºçƒˆå‘å…‰
      const intensity = 1.5 + 3.5 * glow; 
      baseCol.multiplyScalar(intensity);

      lightMesh.setColorAt(i, baseCol);
    }
    lightMesh.instanceMatrix.needsUpdate = true;
    if (lightMesh.instanceColor) lightMesh.instanceColor.needsUpdate = true;
  }

  // ... (æ˜Ÿç©ºã€é›ªèŠ±ç­‰ä¿æŒä¸å˜) ...
  function createStarField() { const geo = new THREE.BufferGeometry(); const pos = []; for (let i = 0; i < 1000; i++) pos.push((Math.random()-0.5)*1000, (Math.random()-0.5)*1000, (Math.random()-0.5)*1000); geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3)); const stars = new THREE.Points(geo, new THREE.PointsMaterial({ color: 0x888888, size: 1.2, transparent: true, opacity: 0.5 })); scene.add(stars); }
  function createSnowTexture() { const size = 128; const canvas = document.createElement('canvas'); canvas.width = canvas.height = size; const ctx = canvas.getContext('2d'); const g = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2); g.addColorStop(0.00, 'rgba(255,255,255,1.00)'); g.addColorStop(0.35, 'rgba(255,255,255,0.95)'); g.addColorStop(0.65, 'rgba(255,255,255,0.45)'); g.addColorStop(1.00, 'rgba(255,255,255,0.00)'); ctx.fillStyle = g; ctx.beginPath(); ctx.arc(size/2, size/2, size/2, 0, Math.PI*2); ctx.fill(); for (let i = 0; i < 180; i++) { const x = Math.random() * size; const y = Math.random() * size; const r = Math.random() * 2.0 + 0.5; const a = Math.random() * 0.08; ctx.fillStyle = `rgba(255,255,255,${a.toFixed(3)})`; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill(); } const tex = new THREE.CanvasTexture(canvas); tex.colorSpace = THREE.SRGBColorSpace; tex.needsUpdate = true; return tex; }
  function createSnowMaterial(spriteTexture, opacity, depthFadeStrength) { return new THREE.ShaderMaterial({ transparent: true, depthWrite: false, blending: THREE.AdditiveBlending, uniforms: { uMap: { value: spriteTexture }, uTime: { value: 0 }, uOpacity: { value: opacity }, uDepthFade: { value: depthFadeStrength } }, vertexShader: `uniform float uTime; attribute float aSize; attribute float aAngle; attribute float aSpin; varying float vAngle; varying float vDepth; void main() { vAngle = aAngle + uTime * aSpin; vec4 mvPosition = modelViewMatrix * vec4(position, 1.0); vDepth = clamp((-mvPosition.z) / 260.0, 0.0, 1.0); float dist = -mvPosition.z; float perspective = clamp(140.0 / dist, 0.6, 3.0); gl_PointSize = aSize * perspective; gl_Position = projectionMatrix * mvPosition; }`, fragmentShader: `uniform sampler2D uMap; uniform float uOpacity; uniform float uDepthFade; varying float vAngle; varying float vDepth; vec2 rotate(vec2 p, float a) { float s = sin(a); float c = cos(a); return vec2(c*p.x - s*p.y, s*p.x + c*p.y); } void main() { vec2 uv = gl_PointCoord - 0.5; uv = rotate(uv, vAngle); uv += 0.5; vec4 tex = texture2D(uMap, uv); float d = distance(gl_PointCoord, vec2(0.5)); float mask = smoothstep(0.52, 0.40, d); float depthFade = mix(1.0, 0.22, vDepth * uDepthFade); vec4 col = vec4(tex.rgb, tex.a * mask * uOpacity * depthFade); if (col.a < 0.02) discard; gl_FragColor = col; }` }); }
  function createSnowSystem(opts) { const geo = new THREE.BufferGeometry(); const positions = new Float32Array(opts.maxCount * 3); const aSize = new Float32Array(opts.maxCount); const aAngle = new Float32Array(opts.maxCount); const aSpin = new Float32Array(opts.maxCount); const data = new Array(opts.maxCount); for (let i = 0; i < opts.maxCount; i++) { const x = (Math.random() - 0.5) * opts.areaX; const y = Math.random() * (opts.topY - opts.bottomY) + opts.bottomY; const z = (Math.random() - 0.5) * opts.areaZ + opts.zBias; positions[i*3] = x; positions[i*3+1] = y; positions[i*3+2] = z; aSize[i] = opts.sizeMin + Math.random() * (opts.sizeMax - opts.sizeMin); aAngle[i] = Math.random() * Math.PI * 2; aSpin[i] = (Math.random() - 0.5) * 0.9; data[i] = { x, y, z, speed: opts.speedMin + Math.random() * (opts.speedMax - opts.speedMin), phase: Math.random() * Math.PI * 2, gust: 0.5 + Math.random() * 0.8 }; } geo.setAttribute('position', new THREE.BufferAttribute(positions, 3)); geo.setAttribute('aSize', new THREE.BufferAttribute(aSize, 1)); geo.setAttribute('aAngle', new THREE.BufferAttribute(aAngle, 1)); geo.setAttribute('aSpin', new THREE.BufferAttribute(aSpin, 1)); geo.setDrawRange(0, opts.initCount); const system = new THREE.Points(geo, opts.material); system.userData = opts; return { system, data }; }
  function createSnowLayers() { const tex = createSnowTexture(); const far = createSnowSystem({ maxCount: CONFIG.snowFarMax, initCount: CONFIG.snowFarInit, areaX: 300, areaZ: 360, topY: 130, bottomY: -130, zBias: -160, sizeMin: 6.0, sizeMax: 12.0, speedMin: 0.08, speedMax: 0.22, drift: 0.35, opacity: 0.42, material: createSnowMaterial(tex, 0.42, 1.0) }); const near = createSnowSystem({ maxCount: CONFIG.snowNearMax, initCount: CONFIG.snowNearInit, areaX: 260, areaZ: 260, topY: 130, bottomY: -130, zBias: 30, sizeMin: 12.0, sizeMax: 26.0, speedMin: 0.18, speedMax: 0.70, drift: 1.10, opacity: 0.88, material: createSnowMaterial(tex, 0.88, 0.6) }); snowFarSystem = far.system; snowFarData = far.data; snowNearSystem = near.system; snowNearData = near.data; scene.add(snowFarSystem); scene.add(snowNearSystem); }
  function updateSnow() { updateWind(); updateSnowSystem(snowFarSystem, snowFarData); updateSnowSystem(snowNearSystem, snowNearData); }
  function updateSnowSystem(system, data) { if (!system) return; const u = system.userData; const posAttr = system.geometry.attributes.position; const pos = posAttr.array; const count = system.geometry.drawRange.count; for (let i = 0; i < count; i++) { const s = data[i]; s.y -= s.speed; s.phase += 0.018 * s.gust; s.x += (Math.sin(s.phase) * 0.10 + Math.sin(s.phase * 0.37) * 0.08) * u.drift + wind.x * (0.03 + 0.03 * u.drift); s.z += (Math.cos(s.phase * 0.9) * 0.08 + Math.sin(s.phase * 0.21) * 0.06) * u.drift + wind.z * (0.03 + 0.03 * u.drift); s.y += Math.sin(s.phase * 0.7) * 0.01 * u.drift; if (s.y < u.bottomY) { s.y = u.topY; s.x = (Math.random() - 0.5) * u.areaX; s.z = (Math.random() - 0.5) * u.areaZ + u.zBias; s.phase = Math.random() * Math.PI * 2; s.gust = 0.5 + Math.random() * 0.8; s.speed = u.speedMin + Math.random() * (u.speedMax - u.speedMin); } pos[i*3] = s.x; pos[i*3 + 1] = s.y; pos[i*3 + 2] = s.z; } posAttr.needsUpdate = true; system.material.uniforms.uTime.value = time; }
  function updateWind() { windTime += 0.01; const baseX = Math.sin(windTime * 0.23) * 0.65 + Math.sin(windTime * 0.07) * 0.35; const baseZ = Math.cos(windTime * 0.19) * 0.55 + Math.sin(windTime * 0.09) * 0.25; const gust = (Math.sin(windTime * 0.9) * 0.5 + Math.sin(windTime * 0.47) * 0.5) * 0.65; const targetX = (baseX + gust) * 0.9; const targetZ = (baseZ - gust * 0.6) * 0.9; wind.x = wind.x * 0.92 + targetX * 0.08; wind.z = wind.z * 0.92 + targetZ * 0.08; wind.strength = Math.min(1.0, Math.sqrt(wind.x * wind.x + wind.z * wind.z)); }
  function updateInstancedMesh(mesh, dataArray) { for (let i = 0; i < dataArray.length; i++) { const item = dataArray[i]; let target = (currentState === STATE.TREE) ? item.treePos : item.scatterPos; if (currentState === STATE.ZOOM) target = item.scatterPos; if (currentState === STATE.SCATTER) item.currentPos.y += Math.sin(time + i) * 0.005; const windDrift = (currentState === STATE.TREE) ? 0.05 : 0.02; const windOffset = new THREE.Vector3(wind.x * windDrift, 0, wind.z * windDrift); item.currentPos.lerp(target.clone().add(windOffset), 0.08); item.rotation.x += item.rotSpeed.x; item.rotation.y += item.rotSpeed.y; item.rotation.z += item.rotSpeed.z; item.rotation.x += Math.sin(time * 0.6 + i) * 0.002 * wind.strength; item.rotation.z += Math.cos(time * 0.5 + i) * 0.002 * wind.strength; let s = item.scale; if (currentState === STATE.ZOOM) s = item.scale * 0.6; dummy.position.copy(item.currentPos); dummy.rotation.copy(item.rotation); dummy.scale.setScalar(s); dummy.updateMatrix(); mesh.setMatrixAt(i, dummy.matrix); } mesh.instanceMatrix.needsUpdate = true; }
  function animate() { requestAnimationFrame(animate); updateFPSAndQuality(); time += 0.01; updateInstancedMesh(goldMesh, logicData.gold); updateInstancedMesh(silverMesh, logicData.silver); updateInstancedMesh(gemMesh, logicData.gem); updateInstancedMesh(emeraldMesh, logicData.emerald); updateInstancedMesh(caneMesh, logicData.cane); updateInstancedMesh(candyMesh, logicData.candy); updateInstancedMesh(bellMesh, logicData.bell); updateInstancedMesh(bowMesh, logicData.bow); updateDustRibbon(); updatePineSilhouette(); updateLightString(); updatePhotos(); if (logicData.star) { const target = (currentState === STATE.TREE) ? logicData.star.userData.treePos : logicData.star.userData.scatterPos; logicData.star.position.lerp(target, 0.05); logicData.star.rotation.y += 0.01; } if (currentState === STATE.ZOOM) { rotationVelocity.x = 0; rotationVelocity.y = 0; } else if (currentState === STATE.SCATTER) { if (isHandPresent) { const deltaX = handPos.x - lastHandPos.x; const deltaY = handPos.y - lastHandPos.y; if (deltaX > 0.002) rotationVelocity.y += deltaX * 0.15; if (Math.abs(deltaY) > 0.002) rotationVelocity.x += deltaY * 0.05; lastHandPos.x = handPos.x; lastHandPos.y = handPos.y; } rotationVelocity.y = Math.min(rotationVelocity.y, 0.05); rotationVelocity.x = Math.max(Math.min(rotationVelocity.x, 0.02), -0.02); mainGroup.rotation.y += rotationVelocity.y; mainGroup.rotation.x += rotationVelocity.x; rotationVelocity.y *= 0.96; rotationVelocity.x *= 0.92; mainGroup.rotation.x *= 0.98; } else if (currentState === STATE.TREE) { mainGroup.rotation.y += 0.003; mainGroup.rotation.x *= 0.95; } updateSnow(); composer.render(); }
  function updateFPSAndQuality() { const now = performance.now(); const dt = now - lastFrameT; lastFrameT = now; const fps = 1000 / Math.max(1, dt); fpsAccum += fps; fpsCount++; if (fpsCount >= 40) { fpsAvg = fpsAccum / fpsCount; fpsAccum = 0; fpsCount = 0; if (fpsAvg < CONFIG.fpsLow && qualityLevel < QUALITY.LOW) { qualityLevel++; applyQuality(); } else if (fpsAvg > CONFIG.fpsHigh && qualityLevel > QUALITY.HIGH) { qualityLevel--; applyQuality(); } } }
  function applyQuality() { if (qualityLevel === QUALITY.HIGH) { renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); bloomPass.strength = 0.65; setSnowDrawRanges(CONFIG.snowFarInit, CONFIG.snowNearInit); currentBasePineOpacity = 0.42; } else if (qualityLevel === QUALITY.MED) { renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.2)); bloomPass.strength = 0.55; setSnowDrawRanges(Math.floor(CONFIG.snowFarInit * 0.75), Math.floor(CONFIG.snowNearInit * 0.70)); currentBasePineOpacity = 0.36; } else { renderer.setPixelRatio(1.0); bloomPass.strength = 0.45; setSnowDrawRanges(Math.floor(CONFIG.snowFarInit * 0.55), Math.floor(CONFIG.snowNearInit * 0.45)); currentBasePineOpacity = 0.28; } }
  function setSnowDrawRanges(farCount, nearCount) { if (snowFarSystem) snowFarSystem.geometry.setDrawRange(0, Math.max(0, Math.min(CONFIG.snowFarMax, farCount))); if (snowNearSystem) snowNearSystem.geometry.setDrawRange(0, Math.max(0, Math.min(CONFIG.snowNearMax, nearCount))); }
  function updatePhotos() { photoMeshes.forEach((mesh, idx) => { let targetPos, targetScale = 2.0; if (currentState === STATE.SCATTER) { targetScale = 4.0; mesh.lookAt(camera.position); } if (currentState === STATE.ZOOM && idx === zoomTargetIndex) { const targetWorldPos = new THREE.Vector3(0, 0, 80); targetPos = mainGroup.worldToLocal(targetWorldPos); targetScale = 4.0; mesh.lookAt(camera.position); } else { targetPos = (currentState === STATE.TREE) ? mesh.userData.treePos : mesh.userData.scatterPos; if (currentState !== STATE.TREE) mesh.position.y += Math.sin(time + idx) * 0.01; if (currentState === STATE.TREE) { mesh.rotation.copy(mesh.userData.baseRot); mesh.rotation.y += 0.01; } } const windOffset = new THREE.Vector3(wind.x * 0.06, 0, wind.z * 0.06); mesh.position.lerp(targetPos.clone().add(windOffset), 0.1); mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1); }); }
  function randomSpherePoint(r) { const u = Math.random(), v = Math.random(); const theta = 2 * Math.PI * u; const phi = Math.acos(2 * v - 1); return new THREE.Vector3(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi)); }
  function shuffleArray(arr) { for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } }
  
  // ======================
  // ä¸Šä¼ ç…§ç‰‡ï¼ˆæ‰‹æœºç«¯ä¼˜åŒ–ï¼šå…ˆç¼©æ”¾/å‹ç¼©å†ç”Ÿæˆçº¹ç†ï¼Œé¿å…æ˜¾å­˜çˆ†æ‰å¯¼è‡´å¡ä½ï¼‰
  // ======================
  const MAX_PHOTO_EDGE = 1024;     // æ‰‹æœºç«¯å»ºè®® 1024ï¼ˆæ›´å¤§å®¹æ˜“å¡/é—ªé€€ï¼‰
  const MAX_PHOTOS = 12;           // ç»™æ‰‹æœºç•™ä½™é‡ï¼ˆå¯æŒ‰éœ€è°ƒå¤§ï¼‰

  document.getElementById('file-input').addEventListener('change', async (e) => {
    const files = Array.from(e.target.files || []);
    if (!files.length) return;

    // ç®€å•ä¿æŠ¤ï¼šé¿å…ä¸€æ¬¡æ€§å¡å¤ªå¤šå¤§å›¾
    const remain = Math.max(0, MAX_PHOTOS - photoMeshes.length);
    const picked = files.slice(0, remain);

    const status = document.getElementById('status-text');
    const prevText = status.innerHTML;
    status.innerHTML = "æ­£åœ¨å¤„ç†ç…§ç‰‡â€¦ <span style='color:#aaa'>(æ‰‹æœºç«¯ä¼šè‡ªåŠ¨å‹ç¼©)</span>";

    for (const file of picked) {
      try {
        // å…³é”®ï¼šä½¿ç”¨ createImageBitmap ç›´æ¥é™åˆ¶å°ºå¯¸ï¼Œå‡å°‘å†…å­˜/è§£ç å¼€é”€
        const bmp = await createImageBitmap(file, {
          resizeWidth: MAX_PHOTO_EDGE,
          resizeHeight: MAX_PHOTO_EDGE,
          resizeQuality: 'high'
        });

        const canvas = document.createElement('canvas');
        canvas.width = bmp.width;
        canvas.height = bmp.height;
        const ctx = canvas.getContext('2d', { alpha: false });
        ctx.drawImage(bmp, 0, 0);
        bmp.close?.();

        addPhotoMeshFromCanvas(canvas);
      } catch (err) {
        console.warn('åŠ è½½å›¾ç‰‡å¤±è´¥:', err);
      }
    }

    status.innerHTML = prevText;
    alert(`å·²æ·»åŠ  ${picked.length} å¼ ç…§ç‰‡`);
    e.target.value = ''; // å…è®¸é‡å¤é€‰åŒä¸€å¼ 
  });

  // ä» Canvas åˆ›å»ºè´´å›¾ï¼ˆæ¯” dataURL + Image æ›´çœå†…å­˜ï¼‰
  function addPhotoMeshFromCanvas(canvas) {
    const tex = new THREE.CanvasTexture(canvas);
    tex.colorSpace = THREE.SRGBColorSpace;

    // âœ… å…³é”®ï¼šå…³é—­ mipmap å¹¶ç”¨çº¿æ€§é‡‡æ ·ï¼ˆç§»åŠ¨ç«¯æ˜¾å­˜å‹åŠ›å°å¾ˆå¤šï¼‰
    tex.generateMipmaps = false;
    tex.minFilter = THREE.LinearFilter;
    tex.magFilter = THREE.LinearFilter;

    // ä¿æŒä½ åŸæ¥çš„â€œç…§ç‰‡ç‰Œâ€å°ºå¯¸ç­–ç•¥
    let w = 4, h = 4;
    const iw = canvas.width || 1;
    const ih = canvas.height || 1;
    if (iw > ih) h = 4 * (ih / iw);
    else w = 4 * (iw / ih);

    const geo = new THREE.PlaneGeometry(w, h);
    const mat = new THREE.MeshBasicMaterial({
      map: tex,
      side: THREE.DoubleSide,
      color: 0xcccccc
    });
    const mesh = new THREE.Mesh(geo, mat);

    // é‡‘è‰²ç›¸æ¡†
    const frame = new THREE.Mesh(
      new THREE.BoxGeometry(w + 0.2, h + 0.2, 0.1),
      new THREE.MeshPhysicalMaterial({ color: 0xffd700, roughness: 0.2, metalness: 1 })
    );
    frame.position.z = -0.06;
    mesh.add(frame);

    // æŒ‚åœ¨æ ‘ä¸Šçš„éšæœºä½ç½®ï¼ˆæ²¿ç”¨ä½ åŸé€»è¾‘ï¼‰
    const h_pos = (Math.random() - 0.5) * CONFIG.treeHeight;
    const normH = (h_pos + CONFIG.treeHeight / 2) / CONFIG.treeHeight;
    const maxR = CONFIG.maxRadius * (1 - normH);
    const r = maxR * (0.3 + 0.6 * Math.sqrt(Math.random()));
    const theta = Math.random() * Math.PI * 2;

    const treePos = new THREE.Vector3(r * Math.cos(theta), h_pos, r * Math.sin(theta));
    const scatterPos = randomSpherePoint(50);

    mesh.userData = {
      treePos,
      scatterPos,
      baseRot: new THREE.Euler(0, Math.random() * Math.PI, 0)
    };
    mesh.position.copy(treePos);

    photoMeshes.push(mesh);
    mainGroup.add(mesh);
  }

async function setupMediaPipe() { const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"); const handLandmarker = await HandLandmarker.createFromOptions(vision, { baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" }, runningMode: "VIDEO", numHands: 1 }); const video = document.getElementById("input-video"); navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 }, frameRate: { ideal: 30, max: 30 } } }).then((stream) => { video.srcObject = stream; video.addEventListener("loadeddata", () => { document.getElementById('loading').style.display = 'none'; document.getElementById('status-text').innerText = "ç³»ç»Ÿå°±ç»ªï¼Œè¯·ä¼¸æ‰‹"; predictWebcam(handLandmarker, video); }); }); }
  
  let lastVideoTime = -1;
  let lastDetectTs = 0;

  // ======================
  // æ‰‹åŠ¿è¯†åˆ«ï¼ˆæ‰‹æœºç«¯ä¼˜åŒ–ï¼šé™é¢‘ï¼Œä¸è¦æ¯å¸§éƒ½ detectï¼‰
  // ======================
  async function predictWebcam(handLandmarker, video) {
    const now = performance.now();

    // çº¦ 15fps åšä¸€æ¬¡è¯†åˆ«ï¼Œæ‘„åƒå¤´é¢„è§ˆæ›´ç¨³
    const SHOULD_DETECT = (now - lastDetectTs) >= 66;

    if (SHOULD_DETECT && video.currentTime !== lastVideoTime) {
      lastDetectTs = now;
      lastVideoTime = video.currentTime;

      const result = handLandmarker.detectForVideo(video, now);

      const canvas = document.getElementById('skeleton-canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (result.landmarks && result.landmarks.length > 0) {
        const landmarks = result.landmarks[0];
        isHandPresent = true;
        drawSkeleton(ctx, landmarks, canvas.width, canvas.height);
        handleGesture(landmarks);
      } else {
        isHandPresent = false;
      }
    }

    requestAnimationFrame(() => predictWebcam(handLandmarker, video));
  }

function drawSkeleton(ctx, landmarks, w, h) { ctx.lineWidth = 3; ctx.strokeStyle = '#00ff88'; ctx.fillStyle = '#ff0044'; const connections = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[5,9],[9,10],[10,11],[11,12],[9,13],[13,14],[14,15],[15,16],[13,17],[17,18],[18,19],[19,20],[0,17]]; ctx.beginPath(); for (let i = 0; i < connections.length; i++) { const s = landmarks[connections[i][0]]; const e = landmarks[connections[i][1]]; ctx.moveTo(s.x * w, s.y * h); ctx.lineTo(e.x * w, e.y * h); } ctx.stroke(); for (let i = 0; i < landmarks.length; i++) { ctx.beginPath(); ctx.arc(landmarks[i].x * w, landmarks[i].y * h, 4, 0, Math.PI * 2); ctx.fill(); } }
  function handleGesture(landmarks) { const palmX = 1 - (landmarks[0].x + landmarks[9].x) / 2; const palmY = (landmarks[0].y + landmarks[9].y) / 2; handPos.x = handPos.x * 0.8 + palmX * 0.2; handPos.y = handPos.y * 0.8 + palmY * 0.2; let folded = 0; [8,12,16,20].forEach(i => { const d = Math.sqrt(Math.pow(landmarks[i].x - landmarks[0].x, 2) + Math.pow(landmarks[i].y - landmarks[0].y, 2)); if (d < 0.35) folded++; }); const dPinch = Math.sqrt(Math.pow(landmarks[4].x - landmarks[8].x, 2) + Math.pow(landmarks[4].y - landmarks[8].y, 2)); const isPinch = dPinch < 0.1; const isFist = folded >= 4; const isOpen = !isFist && !isPinch; const status = document.getElementById('status-text'); if (isPinch && currentState === STATE.SCATTER) { if (photoMeshes.length > 0) { currentState = STATE.ZOOM; status.innerHTML = "çŠ¶æ€: <span style='color:#ffd700'>æŠ“å–ç…§ç‰‡</span>"; if (zoomTargetIndex === -1 && photoMeshes.length > 0) { let minDist = Infinity, bestIdx = 0; const camPos = camera.position; const worldPos = new THREE.Vector3(); photoMeshes.forEach((mesh, idx) => { mesh.getWorldPosition(worldPos); const d = worldPos.distanceTo(camPos); if (d < minDist) { minDist = d; bestIdx = idx; } }); zoomTargetIndex = bestIdx; } } else { status.innerHTML = "çŠ¶æ€: <span style='color:#aaa'>è¯·å…ˆä¸Šä¼ ç…§ç‰‡</span>"; } } else if (isFist) { currentState = STATE.TREE; zoomTargetIndex = -1; rotationVelocity.x = 0; rotationVelocity.y = 0; status.innerHTML = "çŠ¶æ€: <span style='color:#00ff00'>åœ£è¯æ ‘</span>"; } else if (isOpen) { if (currentState === STATE.ZOOM && !isPinch) { currentState = STATE.SCATTER; zoomTargetIndex = -1; } else if (currentState === STATE.TREE) { currentState = STATE.SCATTER; lastHandPos.x = handPos.x; lastHandPos.y = handPos.y; } status.innerHTML = "çŠ¶æ€: <span style='color:#00aaff'>ç²’å­æ•£å¼€</span>"; } }

  initThree();
  animate();
  setupMediaPipe();
  applyQuality();
</script>
</body>
</html>
